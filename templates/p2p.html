<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>P2P Transfer - Secure Drop</title>
    <meta http-equiv="Content-Security-Policy" content="default-src 'none'; script-src 'nonce-{{nonce}}' https://unpkg.com; style-src 'self' 'unsafe-inline'; connect-src 'self' wss: ws:; base-uri 'self';">
    <script nonce="{{nonce}}" src="https://unpkg.com/qrcode-generator@2.0.4/dist/qrcode.js"></script>
    <style>
        :root {
            --bg: #0a0a0a;
            --card: #0d0d0d;
            --text: #E0E0E0;
            --border: #FFFFFF;
            --accent: #B026FF;
            --accent-hover: #9000FF;
            --accent2: #FF6B35;
            --accent3: #00D4FF;
            --font: 'Courier New', monospace;
        }
        * { box-sizing: border-box; }

        @keyframes scanline {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100vh); }
        }

        @keyframes glitch {
            0%, 100% { text-shadow: 2px 0 var(--accent2), -2px 0 var(--accent3); }
            25% { text-shadow: -2px 0 var(--accent2), 2px 0 var(--accent3); }
            50% { text-shadow: 2px 2px var(--accent2), -2px -2px var(--accent3); }
            75% { text-shadow: -2px 2px var(--accent2), 2px -2px var(--accent3); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
        }

        @keyframes codeGlow {
            0%, 100% { box-shadow: 5px 5px 0 0 var(--accent2), 0 0 20px rgba(255, 107, 53, 0.3); }
            50% { box-shadow: 5px 5px 0 0 var(--accent2), 0 0 40px rgba(255, 107, 53, 0.5); }
        }

        body { 
            margin: 0; 
            min-height: 100vh; 
            display: grid; 
            place-items: center; 
            background: var(--bg); 
            color: var(--text); 
            font-family: var(--font); 
            padding: 20px;
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px);
            background-size: 20px 20px;
            pointer-events: none;
            z-index: 0;
        }

        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--accent2), transparent);
            animation: scanline 6s linear infinite;
            pointer-events: none;
            z-index: 0;
            opacity: 0.15;
        }

        .container { position: relative; z-index: 1; }

        .side-text {
            position: fixed;
            font-size: 0.6rem;
            color: #222;
            letter-spacing: 0.3rem;
            text-transform: uppercase;
            white-space: nowrap;
        }

        .side-text.left {
            left: 20px;
            top: 50%;
            transform: rotate(-90deg) translateX(-50%);
            transform-origin: left center;
        }

        .side-text.right {
            right: 20px;
            top: 50%;
            transform: rotate(90deg) translateX(50%);
            transform-origin: right center;
        }

        .float-decor {
            position: fixed;
            font-size: 1.5rem;
            color: var(--accent2);
            opacity: 0.15;
            animation: float 3s ease-in-out infinite;
        }

        .float-decor:nth-child(1) { top: 10%; left: 5%; animation-delay: 0s; }
        .float-decor:nth-child(2) { top: 20%; right: 8%; animation-delay: 0.5s; }
        .float-decor:nth-child(3) { bottom: 15%; left: 10%; animation-delay: 1s; }
        .float-decor:nth-child(4) { bottom: 25%; right: 5%; animation-delay: 1.5s; }

        .neo-box {
            background: var(--card);
            border: 3px solid var(--border);
            box-shadow: 
                8px 8px 0 0 var(--border),
                0 0 30px rgba(255, 107, 53, 0.1);
            padding: 35px;
            width: min(540px, 95vw);
            position: relative;
        }

        .neo-box::before {
            content: '[ P2P::ACTIVE ] ─── [ WEBRTC::ENABLED ] ─── [ E2E::ENCRYPTED ]';
            position: absolute;
            top: -30px;
            left: 0;
            right: 0;
            font-size: 0.55rem;
            color: var(--accent2);
            white-space: nowrap;
            overflow: hidden;
            text-align: center;
            letter-spacing: 0.1rem;
        }

        .neo-box::after {
            content: '└────────────────────────────────────────────────────────────────┘';
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.5rem;
            color: #333;
            white-space: nowrap;
        }

        .header {
            display: flex;
            align-items: center;
            gap: 12px;
            border-bottom: 3px solid var(--border);
            padding-bottom: 15px;
            margin-bottom: 15px;
            position: relative;
        }

        .header::after {
            content: 'DIRECT';
            position: absolute;
            right: 0;
            top: 0;
            font-size: 0.6rem;
            color: #444;
        }

        .header-icon {
            font-size: 1.8rem;
            color: var(--accent2);
            animation: pulse 2s infinite;
            text-shadow: 0 0 10px var(--accent2);
        }

        h1 { 
            margin: 0; 
            letter-spacing: -1px; 
            font-size: 1.3rem;
        }

        .terminal-line {
            font-size: 0.65rem;
            color: #0f0;
            margin-bottom: 15px;
            padding: 8px 12px;
            background: #000;
            border-left: 3px solid #0f0;
            font-family: monospace;
        }

        .terminal-line::before {
            content: '> ';
            color: var(--accent3);
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            font-size: 0.65rem;
            color: #555;
            margin-bottom: 20px;
            padding: 10px 12px;
            background: #000;
            border: 1px solid #222;
            position: relative;
        }

        .status-bar::before {
            content: '⚡';
            position: absolute;
            left: -8px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--accent2);
            font-size: 0.8rem;
        }

        .status-bar .online { color: #0f0; animation: blink 1s step-end infinite; }
        .status-bar .online::before { content: '● '; }

        .code-display {
            font-size: 2.5rem;
            letter-spacing: 0.6rem;
            text-align: center;
            padding: 22px;
            background: #000;
            border: 3px solid var(--accent2);
            margin: 20px 0;
            font-weight: bold;
            color: var(--accent2);
            animation: codeGlow 2s infinite;
            position: relative;
        }

        .code-display::before {
            content: '◢━━━━━◣';
            position: absolute;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.5rem;
            color: #333;
        }

        .code-display::after {
            content: '◥━━━━━◤';
            position: absolute;
            bottom: -12px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.5rem;
            color: #333;
        }

        label { 
            display: block; 
            margin-bottom: 8px; 
            font-weight: bold; 
            font-size: 0.8rem; 
            color: var(--accent3);
            text-transform: uppercase;
            letter-spacing: 0.15rem;
        }

        label::before { content: '//'; color: #444; margin-right: 5px; }

        input, button {
            width: 100%;
            padding: 16px;
            margin-bottom: 15px;
            background: #0a0a0a;
            color: var(--text);
            border: 3px solid var(--border);
            font-family: inherit;
            font-weight: bold;
            font-size: 1rem;
            box-shadow: 5px 5px 0 0 var(--border);
            transition: all 0.1s;
        }

        input:focus { 
            outline: none; 
            border-color: var(--accent3); 
            box-shadow: 5px 5px 0 0 var(--accent3); 
        }

        button { 
            background: var(--accent); 
            color: #000; 
            text-transform: uppercase; 
            cursor: pointer;
            letter-spacing: 0.15rem;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
        }

        button:hover::before { animation: shimmer 0.5s forwards; }

        @keyframes shimmer {
            to { left: 100%; }
        }

        button:hover { background: var(--accent-hover); color: #fff; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        #drop-zone {
            border: 3px dashed var(--border);
            background: #080808;
            padding: 40px 20px;
            text-align: center;
            margin-bottom: 20px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
        }

        #drop-zone::before {
            content: '◢━━━━━━━━━━━━━━◣';
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.5rem;
            color: #333;
        }

        #drop-zone::after {
            content: '◥━━━━━━━━━━━━━━◤';
            position: absolute;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.5rem;
            color: #333;
        }

        #drop-zone.hover { 
            background: var(--accent); 
            color: #000; 
            border-style: solid;
            box-shadow: 0 0 30px var(--accent);
        }

        .status { 
            padding: 15px; 
            margin: 15px 0; 
            border: 2px solid var(--border); 
            background: #000; 
            font-size: 0.85rem;
        }
        .status.success { border-color: #0f0; color: #0f0; }
        .status.error { border-color: #f00; color: #f00; }

        .progress-bar { 
            width: 100%; 
            height: 24px; 
            background: #0a0a0a; 
            margin: 10px 0; 
            border: 2px solid #333;
            position: relative;
            overflow: hidden;
        }

        .progress-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                90deg,
                transparent,
                transparent 10px,
                rgba(255,255,255,0.03) 10px,
                rgba(255,255,255,0.03) 20px
            );
        }

        .progress-fill { 
            height: 100%; 
            background: linear-gradient(90deg, var(--accent3), var(--accent)); 
            width: 0%; 
            transition: width 0.3s;
            box-shadow: 0 0 10px var(--accent3);
        }

        .hidden { display: none; }

        .tab-btns { display: flex; gap: 10px; margin-bottom: 20px; }

        .tab-btn { 
            flex: 1; 
            padding: 14px; 
            background: #0a0a0a; 
            border: 3px solid var(--border); 
            cursor: pointer; 
            text-align: center; 
            font-weight: bold; 
            text-transform: uppercase;
            letter-spacing: 0.08rem;
            box-shadow: 4px 4px 0 0 var(--border);
            transition: all 0.1s;
        }

        .tab-btn:hover {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 0 var(--border);
        }

        .tab-btn.active { 
            background: var(--accent2); 
            color: #000; 
            box-shadow: 4px 4px 0 0 #000;
        }

        .section { display: none; }
        .section.active { display: block; }

        .back-link { 
            display: block; 
            text-align: center; 
            margin-top: 20px; 
            color: #555; 
            text-decoration: none;
            font-size: 0.8rem;
            padding: 12px;
            border: 1px solid transparent;
            transition: all 0.2s;
        }
        .back-link:hover { 
            color: var(--accent3); 
            border-color: var(--accent3);
        }

        #qr-container { text-align: center; margin: 20px 0; }

        #qr-code { 
            display: inline-block; 
            padding: 15px; 
            background: #fff; 
            border: 3px solid var(--border); 
            box-shadow: 6px 6px 0 0 var(--border);
        }
        #qr-code svg { display: block; width: 160px; height: 160px; }

        #qr-label { 
            font-size: 0.7rem; 
            margin-top: 15px; 
            color: var(--accent3); 
            text-transform: uppercase;
            letter-spacing: 0.2rem;
        }

        .footer-decoration {
            text-align: center;
            margin-top: 20px;
            font-size: 0.5rem;
            color: #222;
            letter-spacing: 0.3rem;
        }

        .corner-decoration {
            position: absolute;
            font-size: 1.5rem;
            color: var(--accent2);
            opacity: 0.2;
        }
        .corner-decoration.tl { top: -35px; left: -15px; }
        .corner-decoration.tr { top: -35px; right: -15px; }
        .corner-decoration.bl { bottom: -35px; left: -15px; }
        .corner-decoration.br { bottom: -35px; right: -15px; }

        #file-name {
            padding: 12px;
            background: #000;
            border: 2px solid var(--accent);
            color: var(--accent);
            margin-bottom: 15px;
            font-size: 0.85rem;
            word-break: break-all;
            box-shadow: 0 0 10px rgba(176, 38, 255, 0.2);
        }

        #file-name::before { content: '>> '; color: var(--accent3); }

        .divider {
            text-align: center;
            margin: 15px 0;
            font-size: 0.5rem;
            color: #333;
            letter-spacing: 0.3rem;
        }

        .hacker-text {
            font-size: 0.55rem;
            color: #1a1a1a;
            text-align: center;
            margin-top: 10px;
            letter-spacing: 0.2rem;
        }

        .mode-toggle {
            position: fixed;
            bottom: 10px;
            right: 10px;
            width: 8px;
            height: 8px;
            background: transparent;
            border: none;
            cursor: pointer;
            opacity: 0;
        }

        .mode-toggle:hover { opacity: 0.1; background: var(--accent); }

        body.minimal { background: #111 !important; }
        body.minimal::before, body.minimal::after { display: none !important; }
        body.minimal .side-text,
        body.minimal .float-decor,
        body.minimal .corner-decoration,
        body.minimal .terminal-line,
        body.minimal .hacker-text,
        body.minimal .footer-decoration,
        body.minimal .status-bar::before { display: none !important; }
        body.minimal .neo-box::before,
        body.minimal .neo-box::after,
        body.minimal #drop-zone::before,
        body.minimal #drop-zone::after,
        body.minimal .code-display::before,
        body.minimal .code-display::after { display: none !important; }
        body.minimal .neo-box { 
            box-shadow: 6px 6px 0 0 var(--border) !important;
            background: #1a1a1a !important;
        }
        body.minimal h1 { animation: none !important; text-shadow: none !important; }
        body.minimal label::before { display: none !important; }
        body.minimal #file-name::before { display: none !important; }
        body.minimal .code-display { animation: none !important; box-shadow: 5px 5px 0 0 var(--accent2) !important; }
    </style>
</head>
<body class="minimal">
    <div class="float-decor">◈</div>
    <div class="float-decor">◇</div>
    <div class="float-decor">⬡</div>
    <div class="float-decor">◆</div>

    <div class="side-text left">PEER-TO-PEER TRANSFER ◈ NO SERVER STORAGE ◈ ENCRYPTED</div>
    <div class="side-text right">DIRECT BROWSER CONNECTION ◈ END-TO-END ENCRYPTION</div>

    <div class="container">
        <span class="corner-decoration tl">▛</span>
        <span class="corner-decoration tr">▜</span>
        <div class="neo-box">
            <div class="header">
                <h1>P2P TRANSFER</h1>
            </div>
            
            
            
            
            
            <div class="tab-btns">
                <div class="tab-btn active" data-tab="receive">▼ RECEIVE</div>
                <div class="tab-btn" data-tab="send">▲ SEND</div>
            </div>

            <!-- RECEIVE MODE -->
            <div id="receive" class="section active">
                <label>YOUR CODE:</label>
                <div class="code-display" id="my-code">------</div>
                <div id="qr-container">
                    <div id="qr-code"></div>
                    <div id="qr-label">◇ Scan to connect ◇</div>
                </div>
                <div id="recv-status" class="status hidden"></div>
                <div id="recv-progress" class="hidden">
                    <label>RECEIVING:</label>
                    <div class="progress-bar"><div class="progress-fill" id="recv-fill"></div></div>
                    <div id="recv-info"></div>
                </div>
            </div>

            <!-- SEND MODE -->
            <div id="send" class="section">
                <label>RECEIVER'S CODE:</label>
                <input type="text" id="target-code" placeholder="Enter 6-digit code" maxlength="6" pattern="[0-9]{6}">
                
                <div id="drop-zone">
                    <span id="drop-lbl">◇ DROP FILE HERE ◇<br><br>━━ OR CLICK TO SELECT ━━</span>
                    <input type="file" id="file-input" style="display:none">
                </div>
                <div id="file-name" class="hidden"></div>
                
                <button id="send-btn" disabled>▶ SEND FILE</button>
                
                <div id="send-status" class="status hidden"></div>
                <div id="send-progress" class="hidden">
                    <label>SENDING:</label>
                    <div class="progress-bar"><div class="progress-fill" id="send-fill"></div></div>
                    <div id="send-info"></div>
                </div>
            </div>

            <div class="divider">══════════════════════════════════════════</div>

            <a href="/" class="back-link">◄ BACK TO MAIN</a>

            
            
            <div class="footer-decoration">═══════════════════════════════════════════</div>
        </div>
        <span class="corner-decoration bl">▙</span>
        <span class="corner-decoration br">▟</span>
    </div>

    <button class="mode-toggle" id="mode-toggle" title="Toggle minimal mode"></button>

    <script nonce="{{nonce}}">
    (function () {
        'use strict';

        // Secret mode toggle (click or press M)
        const toggleMinimal = () => {
            document.body.classList.toggle('minimal');
            localStorage.setItem('minimalMode', document.body.classList.contains('minimal'));
        };
        document.getElementById('mode-toggle').addEventListener('click', toggleMinimal);
        document.addEventListener('keydown', (e) => {
            if (e.key === 'm' || e.key === 'M') {
                if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                    toggleMinimal();
                }
            }
        });

        if (localStorage.getItem('minimalMode') === 'true') {
            document.body.classList.add('minimal');
        }

        // --- QR Code Generator using external qrcode-generator library ---
        function generateQR(text) {
            const qr = qrcode(0, 'M');
            qr.addData(text);
            qr.make();
            return qr.createSvgTag({ cellSize: 4, margin: 2, scalable: true });
        }

        // --- State ---
        let ws = null;
        let myCode = '';
        let selectedFile = null;
        let pc = null;
        let dc = null;

        // --- Constants ---
        const CHUNK_SIZE = 64 * 1024; // 64KB chunks for better performance

        // --- Utility Functions ---
        function formatSize(bytes) {
            const units = ['B', 'KB', 'MB', 'GB'];
            let i = 0;
            while (bytes >= 1024 && i < 3) {
                bytes /= 1024;
                i++;
            }
            return bytes.toFixed(2) + ' ' + units[i];
        }

        function showStatus(id, msg, type) {
            const el = document.getElementById(id);
            el.textContent = msg;
            el.className = 'status' + (type ? ' ' + type : '');
            el.classList.remove('hidden');
        }

        function updateProgress(mode, current, total) {
            const pct = (current / total * 100).toFixed(1);
            document.getElementById(mode + '-fill').style.width = pct + '%';
            document.getElementById(mode + '-info').textContent =
                formatSize(current) + ' / ' + formatSize(total) + ' (' + pct + '%)';
        }

        async function computeChecksum(data) {
            const hash = await crypto.subtle.digest('SHA-256', data);
            return Array.from(new Uint8Array(hash))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }

        function base64Encode(uint8Array) {
            let binary = '';
            const len = uint8Array.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(uint8Array[i]);
            }
            return btoa(binary);
        }

        function base64Decode(base64) {
            const binary = atob(base64);
            const len = binary.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes;
        }

        // --- Tab Switching ---
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById(btn.dataset.tab).classList.add('active');
            });
        });

        // --- WebSocket Connection ---
        function connect() {
            const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${proto}//${location.host}/ws`);

            ws.onmessage = async (e) => {
                const msg = JSON.parse(e.data);

                switch (msg.type) {
                    case 'code':
                        myCode = msg.code;
                        document.getElementById('my-code').textContent = myCode;
                        // Generate QR code with URL to send page with code pre-filled
                        const sendUrl = `${location.protocol}//${location.host}/p2p#send:${myCode}`;
                        document.getElementById('qr-code').innerHTML = generateQR(sendUrl);
                        break;

                    case 'offer':
                        await handleOffer(msg.from, msg.data);
                        break;

                    case 'answer':
                        if (pc) await pc.setRemoteDescription(msg.data);
                        break;

                    case 'ice':
                        if (pc && msg.data) await pc.addIceCandidate(msg.data);
                        break;

                    case 'relay-start':
                        ws.send(JSON.stringify({ type: 'relay-ready', target: msg.from }));
                        break;

                    case 'relay-ready':
                        if (window.pendingRelaySend) window.pendingRelaySend();
                        break;

                    case 'relay-meta':
                        relayReceiver.handleMeta(msg.from, msg.data);
                        break;

                    case 'relay-chunk':
                        relayReceiver.handleChunk(msg.data);
                        break;

                    case 'relay-end':
                        relayReceiver.handleEnd(msg.data);
                        break;
                }
            };

            ws.onclose = () => setTimeout(connect, 2000);
        }
        connect();

        // --- Handle URL hash for direct send mode (from QR code scan) ---
        function handleUrlHash() {
            const hash = location.hash;
            if (hash.startsWith('#send:')) {
                const code = hash.slice(6);
                if (code.length === 6 && /^\d{6}$/.test(code)) {
                    // Switch to send tab
                    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
                    document.querySelector('[data-tab="send"]').classList.add('active');
                    document.getElementById('send').classList.add('active');
                    // Pre-fill the code
                    document.getElementById('target-code').value = code;
                }
            }
        }

        // --- File Selection ---
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        const sendBtn = document.getElementById('send-btn');

        dropZone.addEventListener('click', () => fileInput.click());

        ['dragenter', 'dragover'].forEach(e => {
            dropZone.addEventListener(e, ev => {
                ev.preventDefault();
                dropZone.classList.add('hover');
            });
        });

        ['dragleave', 'drop'].forEach(e => {
            dropZone.addEventListener(e, ev => {
                ev.preventDefault();
                dropZone.classList.remove('hover');
            });
        });

        dropZone.addEventListener('drop', e => {
            if (e.dataTransfer.files[0]) selectFile(e.dataTransfer.files[0]);
        });

        fileInput.addEventListener('change', () => {
            if (fileInput.files[0]) selectFile(fileInput.files[0]);
        });

        function selectFile(file) {
            selectedFile = file;
            document.getElementById('drop-lbl').textContent = '◆ FILE SELECTED ◆';
            const fn = document.getElementById('file-name');
            fn.textContent = file.name + ' (' + formatSize(file.size) + ')';
            fn.classList.remove('hidden');
            checkReady();
        }

        document.getElementById('target-code').addEventListener('input', checkReady);

        function checkReady() {
            const code = document.getElementById('target-code').value;
            sendBtn.disabled = !(selectedFile && code.length === 6);
        }

        // Handle URL hash after all setup is complete
        handleUrlHash();

        // --- File Sender ---
        sendBtn.addEventListener('click', startSend);

        async function startSend() {
            const targetCode = document.getElementById('target-code').value;
            if (!selectedFile || targetCode.length !== 6) return;

            sendBtn.disabled = true;
            showStatus('send-status', 'Computing checksum...', '');

            // Compute file checksum
            const fileBuffer = await selectedFile.arrayBuffer();
            const checksum = await computeChecksum(fileBuffer);

            showStatus('send-status', 'Connecting (trying P2P first)...', '');

            // Generate encryption key
            const key = await crypto.subtle.generateKey(
                { name: 'AES-GCM', length: 256 },
                true,
                ['encrypt', 'decrypt']
            );
            const exportedKey = await crypto.subtle.exportKey('raw', key);

            // Create WebRTC connection
            pc = new RTCPeerConnection({
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            });

            let connectionTimeout;
            let connected = false;

            pc.onicecandidate = e => {
                if (e.candidate) {
                    ws.send(JSON.stringify({
                        type: 'ice',
                        target: targetCode,
                        data: e.candidate
                    }));
                }
            };

            pc.oniceconnectionstatechange = () => {
                const state = pc.iceConnectionState;
                if ((state === 'failed' || state === 'disconnected') && !connected) {
                    clearTimeout(connectionTimeout);
                    fallbackToRelay(targetCode, key, exportedKey, checksum);
                }
            };

            // Create data channel
            dc = pc.createDataChannel('file', { ordered: true });
            dc.binaryType = 'arraybuffer';

            dc.onopen = async () => {
                connected = true;
                clearTimeout(connectionTimeout);
                showStatus('send-status', 'P2P connected! Sending...', 'success');
                await sendFileViaDataChannel(key, exportedKey, checksum);
            };

            dc.onerror = () => {
                if (!connected) fallbackToRelay(targetCode, key, exportedKey, checksum);
            };

            // Create and send offer
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            ws.send(JSON.stringify({ type: 'offer', target: targetCode, data: offer }));

            // Timeout - if no connection in 8 seconds, use relay
            connectionTimeout = setTimeout(() => {
                if (!connected) {
                    fallbackToRelay(targetCode, key, exportedKey, checksum);
                }
            }, 8000);
        }

        async function sendFileViaDataChannel(key, exportedKey, checksum) {
            document.getElementById('send-progress').classList.remove('hidden');

            // Read file as array buffer and split into chunks
            const fileBuffer = await selectedFile.arrayBuffer();
            const fileData = new Uint8Array(fileBuffer);
            const totalChunks = Math.ceil(fileData.length / CHUNK_SIZE);

            // Send metadata with checksum and total chunks
            const meta = {
                name: selectedFile.name,
                size: selectedFile.size,
                checksum: checksum,
                totalChunks: totalChunks,
                key: Array.from(new Uint8Array(exportedKey))
            };
            dc.send(JSON.stringify(meta));

            // Send chunks with sequence numbers
            let sent = 0;
            for (let seq = 0; seq < totalChunks; seq++) {
                const start = seq * CHUNK_SIZE;
                const end = Math.min(start + CHUNK_SIZE, fileData.length);
                const chunk = fileData.slice(start, end);

                // Encrypt chunk
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const encrypted = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv },
                    key,
                    chunk
                );

                // Create packet: 4 bytes seq + 12 bytes IV + encrypted data
                const seqBytes = new Uint8Array(4);
                new DataView(seqBytes.buffer).setUint32(0, seq, false);

                const packet = new Uint8Array(4 + 12 + encrypted.byteLength);
                packet.set(seqBytes, 0);
                packet.set(iv, 4);
                packet.set(new Uint8Array(encrypted), 16);

                // Wait for buffer to drain
                while (dc.bufferedAmount > 1024 * 1024) {
                    await new Promise(r => setTimeout(r, 50));
                }

                dc.send(packet);
                sent += chunk.length;
                updateProgress('send', sent, selectedFile.size);
            }

            // Signal end
            dc.send('__END__');
            showStatus('send-status', 'File sent successfully! (P2P)', 'success');
        }

        // --- Relay Fallback ---
        async function fallbackToRelay(targetCode, key, exportedKey, checksum) {
            if (pc) { pc.close(); pc = null; }
            if (dc) { dc.close(); dc = null; }

            showStatus('send-status', 'P2P blocked, using encrypted relay...', '');
            ws.send(JSON.stringify({ type: 'relay-start', target: targetCode }));

            window.pendingRelaySend = async () => {
                document.getElementById('send-progress').classList.remove('hidden');

                // Read file as array buffer
                const fileBuffer = await selectedFile.arrayBuffer();
                const fileData = new Uint8Array(fileBuffer);
                const totalChunks = Math.ceil(fileData.length / CHUNK_SIZE);

                // Send metadata
                const meta = {
                    name: selectedFile.name,
                    size: selectedFile.size,
                    checksum: checksum,
                    totalChunks: totalChunks,
                    key: Array.from(new Uint8Array(exportedKey))
                };
                ws.send(JSON.stringify({
                    type: 'relay-meta',
                    target: targetCode,
                    data: meta
                }));

                // Wait for metadata to be processed
                await new Promise(r => setTimeout(r, 150));

                // Send chunks with sequence numbers
                let sent = 0;
                for (let seq = 0; seq < totalChunks; seq++) {
                    const start = seq * CHUNK_SIZE;
                    const end = Math.min(start + CHUNK_SIZE, fileData.length);
                    const chunk = fileData.slice(start, end);

                    // Encrypt chunk
                    const iv = crypto.getRandomValues(new Uint8Array(12));
                    const encrypted = await crypto.subtle.encrypt(
                        { name: 'AES-GCM', iv },
                        key,
                        chunk
                    );

                    // Create packet: 4 bytes seq + 12 bytes IV + encrypted data
                    const seqBytes = new Uint8Array(4);
                    new DataView(seqBytes.buffer).setUint32(0, seq, false);

                    const packet = new Uint8Array(4 + 12 + encrypted.byteLength);
                    packet.set(seqBytes, 0);
                    packet.set(iv, 4);
                    packet.set(new Uint8Array(encrypted), 16);

                    // Base64 encode for WebSocket
                    const b64 = base64Encode(packet);
                    ws.send(JSON.stringify({
                        type: 'relay-chunk',
                        target: targetCode,
                        data: { seq: seq, payload: b64 }
                    }));

                    sent += chunk.length;
                    updateProgress('send', sent, selectedFile.size);

                    // Throttle
                    if (seq % 3 === 0) {
                        await new Promise(r => setTimeout(r, 15));
                    }
                }

                // Wait then send end with checksum for verification
                await new Promise(r => setTimeout(r, 300));
                ws.send(JSON.stringify({
                    type: 'relay-end',
                    target: targetCode,
                    data: { checksum: checksum, totalChunks: totalChunks }
                }));
                showStatus('send-status', 'File sent! Waiting for verification...', 'success');
            };
        }

        // --- Relay Receiver (with ordered reassembly) ---
        const relayReceiver = {
            key: null,
            fileName: '',
            fileSize: 0,
            checksum: '',
            totalChunks: 0,
            chunks: new Map(), // seq -> decrypted data
            expectedSeq: 0,
            processing: false,
            queue: [],

            reset() {
                this.key = null;
                this.fileName = '';
                this.fileSize = 0;
                this.checksum = '';
                this.totalChunks = 0;
                this.chunks = new Map();
                this.expectedSeq = 0;
                this.processing = false;
                this.queue = [];
            },

            async handleMeta(from, meta) {
                this.reset();
                this.fileName = meta.name;
                this.fileSize = meta.size;
                this.checksum = meta.checksum;
                this.totalChunks = meta.totalChunks;

                this.key = await crypto.subtle.importKey(
                    'raw',
                    new Uint8Array(meta.key),
                    'AES-GCM',
                    false,
                    ['decrypt']
                );

                showStatus('recv-status', 'Receiving (relay): ' + this.fileName, 'success');
                document.getElementById('recv-progress').classList.remove('hidden');
            },

            handleChunk(data) {
                this.queue.push({ type: 'chunk', data: data });
                this.processQueue();
            },

            handleEnd(data) {
                this.queue.push({ type: 'end', data: data });
                this.processQueue();
            },

            async processQueue() {
                if (this.processing) return;
                this.processing = true;

                while (this.queue.length > 0) {
                    const item = this.queue.shift();

                    if (item.type === 'chunk' && this.key) {
                        try {
                            const packet = base64Decode(item.data.payload);
                            const seq = new DataView(packet.buffer).getUint32(0, false);
                            const iv = packet.slice(4, 16);
                            const encrypted = packet.slice(16);

                            const decrypted = await crypto.subtle.decrypt(
                                { name: 'AES-GCM', iv },
                                this.key,
                                encrypted
                            );

                            this.chunks.set(seq, new Uint8Array(decrypted));

                            const received = this.chunks.size * CHUNK_SIZE;
                            updateProgress('recv', Math.min(received, this.fileSize), this.fileSize);
                        } catch (err) {
                            console.error('Decrypt error at chunk:', err);
                        }
                    } else if (item.type === 'end') {
                        await this.finalize(item.data);
                    }
                }

                this.processing = false;
            },

            async finalize(endData) {
                // Wait a moment for any remaining chunks
                await new Promise(r => setTimeout(r, 100));

                // Check we have all chunks
                if (this.chunks.size !== this.totalChunks) {
                    showStatus(
                        'recv-status',
                        `Missing chunks: got ${this.chunks.size}/${this.totalChunks}`,
                        'error'
                    );
                    return;
                }

                // Reassemble in order
                const orderedChunks = [];
                for (let i = 0; i < this.totalChunks; i++) {
                    const chunk = this.chunks.get(i);
                    if (!chunk) {
                        showStatus('recv-status', `Missing chunk ${i}`, 'error');
                        return;
                    }
                    orderedChunks.push(chunk);
                }

                // Combine chunks
                const totalSize = orderedChunks.reduce((sum, c) => sum + c.length, 0);
                const fileData = new Uint8Array(totalSize);
                let offset = 0;
                for (const chunk of orderedChunks) {
                    fileData.set(chunk, offset);
                    offset += chunk.length;
                }

                // Verify checksum
                const receivedChecksum = await computeChecksum(fileData);
                if (receivedChecksum !== this.checksum) {
                    showStatus(
                        'recv-status',
                        'Checksum mismatch! File may be corrupted.',
                        'error'
                    );
                    return;
                }

                // Download file
                const blob = new Blob([fileData]);
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = this.fileName || 'download';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showStatus(
                    'recv-status',
                    'File received: ' + this.fileName + ' (' + formatSize(blob.size) + ') ✓ Verified',
                    'success'
                );

                this.reset();
            }
        };

        // --- WebRTC Receiver ---
        async function handleOffer(from, offer) {
            showStatus('recv-status', 'Incoming connection...', '');

            pc = new RTCPeerConnection({
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            });

            pc.onicecandidate = e => {
                if (e.candidate) {
                    ws.send(JSON.stringify({ type: 'ice', target: from, data: e.candidate }));
                }
            };

            let key = null;
            let fileName = '';
            let fileSize = 0;
            let checksum = '';
            let totalChunks = 0;
            const chunks = new Map();

            pc.ondatachannel = e => {
                dc = e.channel;
                dc.binaryType = 'arraybuffer';

                dc.onmessage = async (ev) => {
                    if (typeof ev.data === 'string') {
                        if (ev.data === '__END__') {
                            // Reassemble in order
                            const orderedChunks = [];
                            for (let i = 0; i < totalChunks; i++) {
                                const chunk = chunks.get(i);
                                if (!chunk) {
                                    showStatus('recv-status', `Missing chunk ${i}`, 'error');
                                    return;
                                }
                                orderedChunks.push(chunk);
                            }

                            // Combine
                            const total = orderedChunks.reduce((s, c) => s + c.length, 0);
                            const fileData = new Uint8Array(total);
                            let off = 0;
                            for (const chunk of orderedChunks) {
                                fileData.set(chunk, off);
                                off += chunk.length;
                            }

                            // Verify checksum
                            const recvChecksum = await computeChecksum(fileData);
                            if (recvChecksum !== checksum) {
                                showStatus('recv-status', 'Checksum mismatch!', 'error');
                                return;
                            }

                            // Download
                            const blob = new Blob([fileData]);
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = fileName;
                            a.click();
                            URL.revokeObjectURL(url);
                            showStatus(
                                'recv-status',
                                'File received: ' + fileName + ' ✓ Verified',
                                'success'
                            );
                            return;
                        }

                        // Metadata
                        const meta = JSON.parse(ev.data);
                        fileName = meta.name;
                        fileSize = meta.size;
                        checksum = meta.checksum;
                        totalChunks = meta.totalChunks;

                        key = await crypto.subtle.importKey(
                            'raw',
                            new Uint8Array(meta.key),
                            'AES-GCM',
                            false,
                            ['decrypt']
                        );

                        showStatus('recv-status', 'Receiving (P2P): ' + fileName, 'success');
                        document.getElementById('recv-progress').classList.remove('hidden');
                    } else {
                        // Encrypted chunk with sequence
                        const packet = new Uint8Array(ev.data);
                        const seq = new DataView(packet.buffer).getUint32(0, false);
                        const iv = packet.slice(4, 16);
                        const encrypted = packet.slice(16);

                        try {
                            const decrypted = await crypto.subtle.decrypt(
                                { name: 'AES-GCM', iv },
                                key,
                                encrypted
                            );
                            chunks.set(seq, new Uint8Array(decrypted));

                            const received = chunks.size * CHUNK_SIZE;
                            updateProgress('recv', Math.min(received, fileSize), fileSize);
                        } catch (err) {
                            showStatus('recv-status', 'Decryption failed', 'error');
                        }
                    }
                };
            };

            await pc.setRemoteDescription(offer);
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            ws.send(JSON.stringify({ type: 'answer', target: from, data: answer }));
        }
    })();
    </script>
</body>
</html>
