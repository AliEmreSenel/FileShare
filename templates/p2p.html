<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>P2P Transfer</title>
    <meta http-equiv="Content-Security-Policy" content="default-src 'none'; script-src 'nonce-{{nonce}}' https://unpkg.com; style-src 'self' 'unsafe-inline'; connect-src 'self' wss: ws:; base-uri 'self';">
    <script nonce="{{nonce}}" src="https://unpkg.com/qrcode-generator@2.0.4/dist/qrcode.js"></script>
    <style>
        :root {
            --bg: #121212;
            --card: #1E1E1E;
            --text: #E0E0E0;
            --border: #FFFFFF;
            --accent: #FF6B35;
            --accent2: #00D4FF;
            --font: 'Courier New', monospace;
        }
        * { box-sizing: border-box; }
        body { margin:0; min-height:100vh; display:grid; place-items:center; background:var(--bg); color:var(--text); font-family:var(--font); padding:20px; }
        .neo-box {
            background: var(--card);
            border: 2px solid var(--border);
            box-shadow: 6px 6px 0 0 var(--border);
            padding: 30px;
            width: min(500px, 95vw);
        }
        h1 { margin-top:0; border-bottom: 2px solid var(--border); padding-bottom: 15px; }
        .code-display {
            font-size: 2.5rem;
            letter-spacing: 0.5rem;
            text-align: center;
            padding: 20px;
            background: #000;
            border: 2px solid var(--accent);
            margin: 20px 0;
            font-weight: bold;
            color: var(--accent);
        }
        label { display: block; margin-bottom: 8px; font-weight: bold; font-size: 0.9rem; color: var(--accent2); }
        input, button {
            width: 100%;
            padding: 15px;
            margin-bottom: 15px;
            background: #2A2A2A;
            color: var(--text);
            border: 2px solid var(--border);
            font-family: inherit;
            font-weight: bold;
            font-size: 1rem;
            box-shadow: 4px 4px 0 0 var(--border);
        }
        input:focus { outline: 2px solid var(--accent2); }
        button { background: var(--accent); color: #000; text-transform: uppercase; cursor: pointer; }
        button:hover { background: var(--accent2); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        #drop-zone {
            border: 2px dashed var(--border);
            background: #252525;
            padding: 30px;
            text-align: center;
            margin-bottom: 20px;
            cursor: pointer;
        }
        #drop-zone.hover { background: var(--accent); color: #000; border-style: solid; }
        .status { padding: 15px; margin: 15px 0; border: 1px solid var(--border); background: #000; }
        .status.success { border-color: #0f0; color: #0f0; }
        .status.error { border-color: #f00; color: #f00; }
        .progress-bar { width: 100%; height: 20px; background: #333; margin: 10px 0; }
        .progress-fill { height: 100%; background: var(--accent2); width: 0%; transition: width 0.3s; }
        .hidden { display: none; }
        .tab-btns { display: flex; gap: 10px; margin-bottom: 20px; }
        .tab-btn { flex: 1; padding: 12px; background: #333; border: 2px solid var(--border); cursor: pointer; text-align: center; font-weight: bold; }
        .tab-btn.active { background: var(--accent); color: #000; }
        .section { display: none; }
        .section.active { display: block; }
        .back-link { display: block; text-align: center; margin-top: 20px; color: var(--accent2); text-decoration: none; }
        .back-link:hover { text-decoration: underline; }
        #qr-container { text-align: center; margin: 20px 0; }
        #qr-code { 
            display: inline-block; 
            padding: 15px; 
            background: #fff; 
            border: 2px solid var(--border); 
            box-shadow: 6px 6px 0 0 var(--border);
        }
        #qr-code svg { display: block; width: 160px; height: 160px; }
        #qr-label { 
            font-size: 0.85rem; 
            margin-top: 12px; 
            color: var(--accent2); 
            text-transform: uppercase;
            letter-spacing: 0.1rem;
        }
    </style>
</head>
<body>
    <div class="neo-box">
        <h1>>>> P2P_TRANSFER</h1>
        
        <div class="tab-btns">
            <div class="tab-btn active" data-tab="receive">RECEIVE</div>
            <div class="tab-btn" data-tab="send">SEND</div>
        </div>

        <!-- RECEIVE MODE -->
        <div id="receive" class="section active">
            <label>YOUR CODE (share with sender):</label>
            <div class="code-display" id="my-code">------</div>
            <div id="qr-container">
                <div id="qr-code"></div>
                <div id="qr-label">Scan to open send page</div>
            </div>
            <div id="recv-status" class="status hidden"></div>
            <div id="recv-progress" class="hidden">
                <label>RECEIVING:</label>
                <div class="progress-bar"><div class="progress-fill" id="recv-fill"></div></div>
                <div id="recv-info"></div>
            </div>
        </div>

        <!-- SEND MODE -->
        <div id="send" class="section">
            <label>RECEIVER'S CODE:</label>
            <input type="text" id="target-code" placeholder="Enter 6-digit code" maxlength="6" pattern="[0-9]{6}">
            
            <div id="drop-zone">
                <span id="drop-lbl">[ DROP FILE HERE ]<br><br>OR CLICK TO BROWSE</span>
                <input type="file" id="file-input" style="display:none">
            </div>
            <div id="file-name" class="hidden"></div>
            
            <button id="send-btn" disabled>SEND FILE</button>
            
            <div id="send-status" class="status hidden"></div>
            <div id="send-progress" class="hidden">
                <label>SENDING:</label>
                <div class="progress-bar"><div class="progress-fill" id="send-fill"></div></div>
                <div id="send-info"></div>
            </div>
        </div>

        <a href="/" class="back-link">« Back to Upload</a>
    </div>

    <script nonce="{{nonce}}">
    (function () {
        'use strict';

        // --- QR Code Generator using external qrcode-generator library ---
        function generateQR(text) {
            const qr = qrcode(0, 'M');
            qr.addData(text);
            qr.make();
            return qr.createSvgTag({ cellSize: 4, margin: 2, scalable: true });
        }

        // --- State ---
        let ws = null;
        let myCode = '';
        let selectedFile = null;
        let pc = null;
        let dc = null;

        // --- Constants ---
        const CHUNK_SIZE = 64 * 1024; // 64KB chunks for better performance

        // --- Utility Functions ---
        function formatSize(bytes) {
            const units = ['B', 'KB', 'MB', 'GB'];
            let i = 0;
            while (bytes >= 1024 && i < 3) {
                bytes /= 1024;
                i++;
            }
            return bytes.toFixed(2) + ' ' + units[i];
        }

        function showStatus(id, msg, type) {
            const el = document.getElementById(id);
            el.textContent = msg;
            el.className = 'status' + (type ? ' ' + type : '');
            el.classList.remove('hidden');
        }

        function updateProgress(mode, current, total) {
            const pct = (current / total * 100).toFixed(1);
            document.getElementById(mode + '-fill').style.width = pct + '%';
            document.getElementById(mode + '-info').textContent =
                formatSize(current) + ' / ' + formatSize(total) + ' (' + pct + '%)';
        }

        async function computeChecksum(data) {
            const hash = await crypto.subtle.digest('SHA-256', data);
            return Array.from(new Uint8Array(hash))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }

        function base64Encode(uint8Array) {
            let binary = '';
            const len = uint8Array.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(uint8Array[i]);
            }
            return btoa(binary);
        }

        function base64Decode(base64) {
            const binary = atob(base64);
            const len = binary.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes;
        }

        // --- Tab Switching ---
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById(btn.dataset.tab).classList.add('active');
            });
        });

        // --- WebSocket Connection ---
        function connect() {
            const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${proto}//${location.host}/ws`);

            ws.onmessage = async (e) => {
                const msg = JSON.parse(e.data);

                switch (msg.type) {
                    case 'code':
                        myCode = msg.code;
                        document.getElementById('my-code').textContent = myCode;
                        // Generate QR code with URL to send page with code pre-filled
                        const sendUrl = `${location.protocol}//${location.host}/p2p#send:${myCode}`;
                        document.getElementById('qr-code').innerHTML = generateQR(sendUrl);
                        break;

                    case 'offer':
                        await handleOffer(msg.from, msg.data);
                        break;

                    case 'answer':
                        if (pc) await pc.setRemoteDescription(msg.data);
                        break;

                    case 'ice':
                        if (pc && msg.data) await pc.addIceCandidate(msg.data);
                        break;

                    case 'relay-start':
                        ws.send(JSON.stringify({ type: 'relay-ready', target: msg.from }));
                        break;

                    case 'relay-ready':
                        if (window.pendingRelaySend) window.pendingRelaySend();
                        break;

                    case 'relay-meta':
                        relayReceiver.handleMeta(msg.from, msg.data);
                        break;

                    case 'relay-chunk':
                        relayReceiver.handleChunk(msg.data);
                        break;

                    case 'relay-end':
                        relayReceiver.handleEnd(msg.data);
                        break;
                }
            };

            ws.onclose = () => setTimeout(connect, 2000);
        }
        connect();

        // --- Handle URL hash for direct send mode (from QR code scan) ---
        function handleUrlHash() {
            const hash = location.hash;
            if (hash.startsWith('#send:')) {
                const code = hash.slice(6);
                if (code.length === 6 && /^\d{6}$/.test(code)) {
                    // Switch to send tab
                    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
                    document.querySelector('[data-tab="send"]').classList.add('active');
                    document.getElementById('send').classList.add('active');
                    // Pre-fill the code
                    document.getElementById('target-code').value = code;
                }
            }
        }

        // --- File Selection ---
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        const sendBtn = document.getElementById('send-btn');

        dropZone.addEventListener('click', () => fileInput.click());

        ['dragenter', 'dragover'].forEach(e => {
            dropZone.addEventListener(e, ev => {
                ev.preventDefault();
                dropZone.classList.add('hover');
            });
        });

        ['dragleave', 'drop'].forEach(e => {
            dropZone.addEventListener(e, ev => {
                ev.preventDefault();
                dropZone.classList.remove('hover');
            });
        });

        dropZone.addEventListener('drop', e => {
            if (e.dataTransfer.files[0]) selectFile(e.dataTransfer.files[0]);
        });

        fileInput.addEventListener('change', () => {
            if (fileInput.files[0]) selectFile(fileInput.files[0]);
        });

        function selectFile(file) {
            selectedFile = file;
            document.getElementById('drop-lbl').textContent = '>> FILE SELECTED <<';
            const fn = document.getElementById('file-name');
            fn.textContent = file.name + ' (' + formatSize(file.size) + ')';
            fn.classList.remove('hidden');
            checkReady();
        }

        document.getElementById('target-code').addEventListener('input', checkReady);

        function checkReady() {
            const code = document.getElementById('target-code').value;
            sendBtn.disabled = !(selectedFile && code.length === 6);
        }

        // Handle URL hash after all setup is complete
        handleUrlHash();

        // --- File Sender ---
        sendBtn.addEventListener('click', startSend);

        async function startSend() {
            const targetCode = document.getElementById('target-code').value;
            if (!selectedFile || targetCode.length !== 6) return;

            sendBtn.disabled = true;
            showStatus('send-status', 'Computing checksum...', '');

            // Compute file checksum
            const fileBuffer = await selectedFile.arrayBuffer();
            const checksum = await computeChecksum(fileBuffer);

            showStatus('send-status', 'Connecting (trying P2P first)...', '');

            // Generate encryption key
            const key = await crypto.subtle.generateKey(
                { name: 'AES-GCM', length: 256 },
                true,
                ['encrypt', 'decrypt']
            );
            const exportedKey = await crypto.subtle.exportKey('raw', key);

            // Create WebRTC connection
            pc = new RTCPeerConnection({
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            });

            let connectionTimeout;
            let connected = false;

            pc.onicecandidate = e => {
                if (e.candidate) {
                    ws.send(JSON.stringify({
                        type: 'ice',
                        target: targetCode,
                        data: e.candidate
                    }));
                }
            };

            pc.oniceconnectionstatechange = () => {
                const state = pc.iceConnectionState;
                if ((state === 'failed' || state === 'disconnected') && !connected) {
                    clearTimeout(connectionTimeout);
                    fallbackToRelay(targetCode, key, exportedKey, checksum);
                }
            };

            // Create data channel
            dc = pc.createDataChannel('file', { ordered: true });
            dc.binaryType = 'arraybuffer';

            dc.onopen = async () => {
                connected = true;
                clearTimeout(connectionTimeout);
                showStatus('send-status', 'P2P connected! Sending...', 'success');
                await sendFileViaDataChannel(key, exportedKey, checksum);
            };

            dc.onerror = () => {
                if (!connected) fallbackToRelay(targetCode, key, exportedKey, checksum);
            };

            // Create and send offer
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            ws.send(JSON.stringify({ type: 'offer', target: targetCode, data: offer }));

            // Timeout - if no connection in 8 seconds, use relay
            connectionTimeout = setTimeout(() => {
                if (!connected) {
                    fallbackToRelay(targetCode, key, exportedKey, checksum);
                }
            }, 8000);
        }

        async function sendFileViaDataChannel(key, exportedKey, checksum) {
            document.getElementById('send-progress').classList.remove('hidden');

            // Read file as array buffer and split into chunks
            const fileBuffer = await selectedFile.arrayBuffer();
            const fileData = new Uint8Array(fileBuffer);
            const totalChunks = Math.ceil(fileData.length / CHUNK_SIZE);

            // Send metadata with checksum and total chunks
            const meta = {
                name: selectedFile.name,
                size: selectedFile.size,
                checksum: checksum,
                totalChunks: totalChunks,
                key: Array.from(new Uint8Array(exportedKey))
            };
            dc.send(JSON.stringify(meta));

            // Send chunks with sequence numbers
            let sent = 0;
            for (let seq = 0; seq < totalChunks; seq++) {
                const start = seq * CHUNK_SIZE;
                const end = Math.min(start + CHUNK_SIZE, fileData.length);
                const chunk = fileData.slice(start, end);

                // Encrypt chunk
                const iv = crypto.getRandomValues(new Uint8Array(12));
                const encrypted = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv },
                    key,
                    chunk
                );

                // Create packet: 4 bytes seq + 12 bytes IV + encrypted data
                const seqBytes = new Uint8Array(4);
                new DataView(seqBytes.buffer).setUint32(0, seq, false);

                const packet = new Uint8Array(4 + 12 + encrypted.byteLength);
                packet.set(seqBytes, 0);
                packet.set(iv, 4);
                packet.set(new Uint8Array(encrypted), 16);

                // Wait for buffer to drain
                while (dc.bufferedAmount > 1024 * 1024) {
                    await new Promise(r => setTimeout(r, 50));
                }

                dc.send(packet);
                sent += chunk.length;
                updateProgress('send', sent, selectedFile.size);
            }

            // Signal end
            dc.send('__END__');
            showStatus('send-status', 'File sent successfully! (P2P)', 'success');
        }

        // --- Relay Fallback ---
        async function fallbackToRelay(targetCode, key, exportedKey, checksum) {
            if (pc) { pc.close(); pc = null; }
            if (dc) { dc.close(); dc = null; }

            showStatus('send-status', 'P2P blocked, using encrypted relay...', '');
            ws.send(JSON.stringify({ type: 'relay-start', target: targetCode }));

            window.pendingRelaySend = async () => {
                document.getElementById('send-progress').classList.remove('hidden');

                // Read file as array buffer
                const fileBuffer = await selectedFile.arrayBuffer();
                const fileData = new Uint8Array(fileBuffer);
                const totalChunks = Math.ceil(fileData.length / CHUNK_SIZE);

                // Send metadata
                const meta = {
                    name: selectedFile.name,
                    size: selectedFile.size,
                    checksum: checksum,
                    totalChunks: totalChunks,
                    key: Array.from(new Uint8Array(exportedKey))
                };
                ws.send(JSON.stringify({
                    type: 'relay-meta',
                    target: targetCode,
                    data: meta
                }));

                // Wait for metadata to be processed
                await new Promise(r => setTimeout(r, 150));

                // Send chunks with sequence numbers
                let sent = 0;
                for (let seq = 0; seq < totalChunks; seq++) {
                    const start = seq * CHUNK_SIZE;
                    const end = Math.min(start + CHUNK_SIZE, fileData.length);
                    const chunk = fileData.slice(start, end);

                    // Encrypt chunk
                    const iv = crypto.getRandomValues(new Uint8Array(12));
                    const encrypted = await crypto.subtle.encrypt(
                        { name: 'AES-GCM', iv },
                        key,
                        chunk
                    );

                    // Create packet: 4 bytes seq + 12 bytes IV + encrypted data
                    const seqBytes = new Uint8Array(4);
                    new DataView(seqBytes.buffer).setUint32(0, seq, false);

                    const packet = new Uint8Array(4 + 12 + encrypted.byteLength);
                    packet.set(seqBytes, 0);
                    packet.set(iv, 4);
                    packet.set(new Uint8Array(encrypted), 16);

                    // Base64 encode for WebSocket
                    const b64 = base64Encode(packet);
                    ws.send(JSON.stringify({
                        type: 'relay-chunk',
                        target: targetCode,
                        data: { seq: seq, payload: b64 }
                    }));

                    sent += chunk.length;
                    updateProgress('send', sent, selectedFile.size);

                    // Throttle
                    if (seq % 3 === 0) {
                        await new Promise(r => setTimeout(r, 15));
                    }
                }

                // Wait then send end with checksum for verification
                await new Promise(r => setTimeout(r, 300));
                ws.send(JSON.stringify({
                    type: 'relay-end',
                    target: targetCode,
                    data: { checksum: checksum, totalChunks: totalChunks }
                }));
                showStatus('send-status', 'File sent! Waiting for verification...', 'success');
            };
        }

        // --- Relay Receiver (with ordered reassembly) ---
        const relayReceiver = {
            key: null,
            fileName: '',
            fileSize: 0,
            checksum: '',
            totalChunks: 0,
            chunks: new Map(), // seq -> decrypted data
            expectedSeq: 0,
            processing: false,
            queue: [],

            reset() {
                this.key = null;
                this.fileName = '';
                this.fileSize = 0;
                this.checksum = '';
                this.totalChunks = 0;
                this.chunks = new Map();
                this.expectedSeq = 0;
                this.processing = false;
                this.queue = [];
            },

            async handleMeta(from, meta) {
                this.reset();
                this.fileName = meta.name;
                this.fileSize = meta.size;
                this.checksum = meta.checksum;
                this.totalChunks = meta.totalChunks;

                this.key = await crypto.subtle.importKey(
                    'raw',
                    new Uint8Array(meta.key),
                    'AES-GCM',
                    false,
                    ['decrypt']
                );

                showStatus('recv-status', 'Receiving (relay): ' + this.fileName, 'success');
                document.getElementById('recv-progress').classList.remove('hidden');
            },

            handleChunk(data) {
                this.queue.push({ type: 'chunk', data: data });
                this.processQueue();
            },

            handleEnd(data) {
                this.queue.push({ type: 'end', data: data });
                this.processQueue();
            },

            async processQueue() {
                if (this.processing) return;
                this.processing = true;

                while (this.queue.length > 0) {
                    const item = this.queue.shift();

                    if (item.type === 'chunk' && this.key) {
                        try {
                            const packet = base64Decode(item.data.payload);
                            const seq = new DataView(packet.buffer).getUint32(0, false);
                            const iv = packet.slice(4, 16);
                            const encrypted = packet.slice(16);

                            const decrypted = await crypto.subtle.decrypt(
                                { name: 'AES-GCM', iv },
                                this.key,
                                encrypted
                            );

                            this.chunks.set(seq, new Uint8Array(decrypted));

                            const received = this.chunks.size * CHUNK_SIZE;
                            updateProgress('recv', Math.min(received, this.fileSize), this.fileSize);
                        } catch (err) {
                            console.error('Decrypt error at chunk:', err);
                        }
                    } else if (item.type === 'end') {
                        await this.finalize(item.data);
                    }
                }

                this.processing = false;
            },

            async finalize(endData) {
                // Wait a moment for any remaining chunks
                await new Promise(r => setTimeout(r, 100));

                // Check we have all chunks
                if (this.chunks.size !== this.totalChunks) {
                    showStatus(
                        'recv-status',
                        `Missing chunks: got ${this.chunks.size}/${this.totalChunks}`,
                        'error'
                    );
                    return;
                }

                // Reassemble in order
                const orderedChunks = [];
                for (let i = 0; i < this.totalChunks; i++) {
                    const chunk = this.chunks.get(i);
                    if (!chunk) {
                        showStatus('recv-status', `Missing chunk ${i}`, 'error');
                        return;
                    }
                    orderedChunks.push(chunk);
                }

                // Combine chunks
                const totalSize = orderedChunks.reduce((sum, c) => sum + c.length, 0);
                const fileData = new Uint8Array(totalSize);
                let offset = 0;
                for (const chunk of orderedChunks) {
                    fileData.set(chunk, offset);
                    offset += chunk.length;
                }

                // Verify checksum
                const receivedChecksum = await computeChecksum(fileData);
                if (receivedChecksum !== this.checksum) {
                    showStatus(
                        'recv-status',
                        'Checksum mismatch! File may be corrupted.',
                        'error'
                    );
                    return;
                }

                // Download file
                const blob = new Blob([fileData]);
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = this.fileName || 'download';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showStatus(
                    'recv-status',
                    'File received: ' + this.fileName + ' (' + formatSize(blob.size) + ') ✓ Verified',
                    'success'
                );

                this.reset();
            }
        };

        // --- WebRTC Receiver ---
        async function handleOffer(from, offer) {
            showStatus('recv-status', 'Incoming connection...', '');

            pc = new RTCPeerConnection({
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            });

            pc.onicecandidate = e => {
                if (e.candidate) {
                    ws.send(JSON.stringify({ type: 'ice', target: from, data: e.candidate }));
                }
            };

            let key = null;
            let fileName = '';
            let fileSize = 0;
            let checksum = '';
            let totalChunks = 0;
            const chunks = new Map();

            pc.ondatachannel = e => {
                dc = e.channel;
                dc.binaryType = 'arraybuffer';

                dc.onmessage = async (ev) => {
                    if (typeof ev.data === 'string') {
                        if (ev.data === '__END__') {
                            // Reassemble in order
                            const orderedChunks = [];
                            for (let i = 0; i < totalChunks; i++) {
                                const chunk = chunks.get(i);
                                if (!chunk) {
                                    showStatus('recv-status', `Missing chunk ${i}`, 'error');
                                    return;
                                }
                                orderedChunks.push(chunk);
                            }

                            // Combine
                            const total = orderedChunks.reduce((s, c) => s + c.length, 0);
                            const fileData = new Uint8Array(total);
                            let off = 0;
                            for (const chunk of orderedChunks) {
                                fileData.set(chunk, off);
                                off += chunk.length;
                            }

                            // Verify checksum
                            const recvChecksum = await computeChecksum(fileData);
                            if (recvChecksum !== checksum) {
                                showStatus('recv-status', 'Checksum mismatch!', 'error');
                                return;
                            }

                            // Download
                            const blob = new Blob([fileData]);
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = fileName;
                            a.click();
                            URL.revokeObjectURL(url);
                            showStatus(
                                'recv-status',
                                'File received: ' + fileName + ' ✓ Verified',
                                'success'
                            );
                            return;
                        }

                        // Metadata
                        const meta = JSON.parse(ev.data);
                        fileName = meta.name;
                        fileSize = meta.size;
                        checksum = meta.checksum;
                        totalChunks = meta.totalChunks;

                        key = await crypto.subtle.importKey(
                            'raw',
                            new Uint8Array(meta.key),
                            'AES-GCM',
                            false,
                            ['decrypt']
                        );

                        showStatus('recv-status', 'Receiving (P2P): ' + fileName, 'success');
                        document.getElementById('recv-progress').classList.remove('hidden');
                    } else {
                        // Encrypted chunk with sequence
                        const packet = new Uint8Array(ev.data);
                        const seq = new DataView(packet.buffer).getUint32(0, false);
                        const iv = packet.slice(4, 16);
                        const encrypted = packet.slice(16);

                        try {
                            const decrypted = await crypto.subtle.decrypt(
                                { name: 'AES-GCM', iv },
                                key,
                                encrypted
                            );
                            chunks.set(seq, new Uint8Array(decrypted));

                            const received = chunks.size * CHUNK_SIZE;
                            updateProgress('recv', Math.min(received, fileSize), fileSize);
                        } catch (err) {
                            showStatus('recv-status', 'Decryption failed', 'error');
                        }
                    }
                };
            };

            await pc.setRemoteDescription(offer);
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            ws.send(JSON.stringify({ type: 'answer', target: from, data: answer }));
        }
    })();
    </script>
</body>
</html>
